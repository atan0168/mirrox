<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { 
      margin: 0; 
      padding: 0; 
      overflow: hidden; 
      background: transparent;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    model-viewer {
      width: 100%;
      height: 100%;
      background-color: transparent;
      animation: gentle-bounce 3s ease-in-out infinite;
    }
    @keyframes gentle-bounce {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-5px); }
    }
    @keyframes gentle-sway {
      0%, 100% { transform: rotateY(-2deg); }
      50% { transform: rotateY(2deg); }
    }
    .sway-animation {
      animation: gentle-sway 4s ease-in-out infinite;
    }
  </style>
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
</head>
<body>
  <model-viewer
    src="https://models.readyplayer.me/64bfa15f0e72c63d7c3934a6.glb"
    alt="Ready Player Me Avatar"
    camera-controls
    disable-zoom
    environment-image="neutral"
    shadow-intensity="1"
    camera-orbit="0deg 75deg 3.6m"
    min-camera-orbit="auto 30deg 2.5m"
    max-camera-orbit="auto 120deg 4.5m"
    interaction-prompt="none"
    loading="eager"
    animation-name="Idle"
    autoplay>
    <script>
      const modelViewer = document.querySelector('model-viewer');
      console.log('modelViewer element:', modelViewer);
      let isCustomAnimating = false;
      
      // Listen for messages from React Native
      window.addEventListener('message', function(event) {
        console.log('Message received in WebView:', event.data);
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'TRIGGER_ANIMATION') {
            console.log('TRIGGER_ANIMATION received');
            triggerCustomAnimation();
          }
        } catch (e) {
          console.log('Message parsing error:', e);
        }
      });
      
      function triggerCustomAnimation() {
        console.log('triggerCustomAnimation called');
        if (isCustomAnimating) {
          console.log('Animation already in progress');
          return;
        }
        
        isCustomAnimating = true;
        
        // Add custom CSS animation to the model viewer
        console.log('Applying CSS animation');
        modelViewer.style.animation = 'none';
        modelViewer.style.transform = 'scale(1)';
        
        // Create expression animation sequence
        let step = 0;
        const animationSteps = [
          { scale: 1.05, rotateY: 5, duration: 500 },
          { scale: 1.1, rotateY: 0, duration: 500 },
          { scale: 1.05, rotateY: -5, duration: 500 },
          { scale: 1, rotateY: 0, duration: 500 }
        ];
        
        function runAnimationStep() {
          if (step < animationSteps.length) {
            const currentStep = animationSteps[step];
            modelViewer.style.transition = `transform ${currentStep.duration}ms ease-in-out`;
            modelViewer.style.transform = `scale(${currentStep.scale}) rotateY(${currentStep.rotateY}deg)`;
            
            setTimeout(() => {
              step++;
              runAnimationStep();
            }, currentStep.duration);
          } else {
            // Reset to original state
            setTimeout(() => {
              modelViewer.style.animation = 'gentle-bounce 3s ease-in-out infinite';
              modelViewer.style.transform = '';
              modelViewer.style.transition = '';
              isCustomAnimating = false;
            }, 200);
          }
        }
        
        runAnimationStep();
        
        // Try to trigger a built-in animation if available
        console.log('Available animations:', modelViewer.availableAnimations);
        if (modelViewer.availableAnimations && modelViewer.availableAnimations.length > 0) {
          const originalAnimation = modelViewer.animationName;
          
          // Look for expression or emotion animations
          const expressionAnimations = modelViewer.availableAnimations.filter(name => 
            name.toLowerCase().includes('expression') || 
            name.toLowerCase().includes('emotion') ||
            name.toLowerCase().includes('happy') ||
            name.toLowerCase().includes('smile')
          );
          
          if (expressionAnimations.length > 0) {
            modelViewer.animationName = expressionAnimations[0];
            modelViewer.currentTime = 0;
            modelViewer.play();
            
            // Return to original animation after animation completes
            setTimeout(() => {
              modelViewer.animationName = originalAnimation;
            }, 2000);
          }
        } else {
          console.log('No built-in animations found');
        }
        
        // Send confirmation back to React Native
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify({
            type: 'ANIMATION_TRIGGERED',
            success: true
          }));
        }
      }
      
      modelViewer.addEventListener('load', () => {
        console.log('model-viewer has loaded the model');
        // Add subtle rocking motion as fallback
        let angle = 0;
        function animate() {
          angle += 0.01;
          const rockingAngle = Math.sin(angle) * 5;
          modelViewer.cameraOrbit = `${rockingAngle}deg 75deg 3.6m`;
          requestAnimationFrame(animate);
        }
        animate();
      });

      modelViewer.addEventListener('error', (event) => {
        console.error('model-viewer error:', event.detail);
      });
    </script>
  </model-viewer>
</body>
</html>